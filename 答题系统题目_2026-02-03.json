[
  {
    "id": 1769045494159.2468,
    "question": "简述值类型和引用类型有什么区别",
    "answer": "值类型:包含了所有简单类型(整数、浮点、bool、char)、struct、enum.\n继承自System.ValueTyoe\n引用类型包含了string,object,class,interface,delegate,array\n继承自System.Object"
  },
  {
    "id": 1769045584624,
    "question": "4.请简述private,public,protected,internal的区别",
    "answer": "public:对任何类和成员都公开,无限制访问\nprivate:仅对该类公开\nprotected:对该类和其派生类公开\ninternal:只能在包含该类的程序集中访问该类\nprotected internal: protected + internal"
  },
  {
    "id": 1769046584310,
    "question": "请描述Interface与抽象类之间的不同",
    "answer": "1.接口不是类不能实例化抽象类可以间接实例化\n2.接口是完全抽象抽象类为部分抽象\n3.接口可以多继承抽象类是单继承"
  },
  {
    "id": 1769046855503,
    "question": "13.C#String类型比stringBuilder类型的优势是什么?",
    "answer": "如果是处理字符串的话,用string中的方法每次都需要创建一一个新的字符串对象并且分配新的内存地\n址,而stringBuilder是在原来的内存里对字符串进行修改,所以在字符串处理\n方面还是建议用stringBuilder这样比较节约内存。但是string类的方方法和功能仍然还是比stringBuilder\n类要强。\nstring类由于具有不可变性(即对一个string对象进行任何更改时,其实都是创建另外一个string类的\n对象),所以当需要频繁的对一个string类对象进行更改的时候,建议使用StringBuilder类,\nStringBuilder类的原理是首先在内存中开辟一定大小的内存空间,当对此 StringBuilder类对象进行更\n改时,如果内存空间大小不够,会对此内存空间进行扩充,而不是是重新创建一个对象,这样如果对\n一个字符串对象进行频繁操作的时候,不会造成过多的内存浪费,其实本质上并没有很大区别,都是\n用来存储和操作字符串的,唯一的区别就在于性能上。\nString主要用于公共API,通用性好、用途广泛、读取性能高高、占用内存小。\nStringBuilder主要用于拼接String,修改性能好。\n不过现在的编译器已经把String的+操作优化成StringBuilder了,所以一般用String就可以了\nString是不可变的,所以天然线程同步。\nStringBuilder可变,非线程同步。"
  },
  {
    "id": 1769047043001,
    "question": "15.数列1,1,2,3,5,8,13...第n位数是多少?用C#递归算法实现",
    "answer": "public int CountNumber(int num) {\n       if (num == 1 || num == 2) {\n           return 1;\n       } else {\n           return CountNumber(num -1) + CountNumber(num-2);\n       }\n  }"
  },
  {
    "id": 1769047908546,
    "question": "20.C#中委托和接口有什么区别?各用在什么场合?",
    "answer": "**接口(interface)**是约束类应该具备的功能集合,约束了类应该该具备的功能,使类从千变万化的具\n体逻辑中解脱出来,便于类的管理和扩展,同时又合理解决了类的单继承问题。\nC#中的委托,是约束方法集合的一个类,可以便捷的使用委托对这个方法集合进行操作。\n在以下情况中使用接口:\n1.无法使用继承的场合\n2.完全抽象的场合\n3.多人协作的场合\n以上等等\n在以下情况中使用委托:多用于事件处理中"
  },
  {
    "id": 1769048168093,
    "question": "23.For,foreach,Enumerator.MoveNext的使用,与内存消耗情况",
    "answer": "for循环可以通过索引依次进行遍历,foreach和Enumerator.MloveNext通过迭代的方式进行遍历。\n内存消耗上本质上并没有太大的区别。\n但是在Unity中的Update中,一般不推荐使用foreach因为会贵留内存垃圾。"
  },
  {
    "id": 1769048454245,
    "question": "33.foreach迭代器遍历和for循环遍历的区别",
    "answer": "如果集合需要foreach遍历,是否可行,存在一定问题\nforeach中的迭代变量item是的只读,不能对其进行修改,比如list.Remove (item)操作\nforeach只读的时候记录下来,在对记录做操作,或者直接用for循环遍历\nforeach对int[数组循环已经不产生GC,避免对ArrayList进行遍历\nfor语句中初始化变量i的作用域,循环体内部可见。\n通过索引进行遍历,可以根据索引对所遍历集合进行修改\nunity中for循环使用lambda表达式注意闭包问题\nforeach遍历原理\n任何集合类(Array)对象都有一个GetEnumerator()方法,该方法去可以返回一个实现了IEnumerator\n接口的对象。\n这个返回的IEnumerator对象既不是集合类对象,也不是集合的元无素类对象,它是一个独立的类对\n象。\n通过这个实现了IEnumerator接口对象A,可以遍历访问集合类对象中的每一个元素对象\n对象A访问MoveNext方法,方法为真,就可以访问Current方法,读取到集合的元素。"
  },
  {
    "id": 1769048797612,
    "question": "34.C#和C++的区别?",
    "answer": "简单的说:C#与C++比较的话,最重要的特性就是C#是一种完全面面向对象的语言,而C++不是,另外C#是基于IL中间语言\n和NETFramework CLR的,在可移植性,可维护性和强壮性都比C++有很大的改进。C#的设计目标是用来开发快速稳定可扩展的应\n用程序,当然也可以通过Interop和Pinvoke完成一些底层操作\n具体对比:\n1.继承:C++支持多继承,C#类只能继承一个基类中的实现但可以实现多个接口。\n2.数组:声明C#数组和声明C++数组的语法不同。在C#中,\"1\"标记出现在数组类型的后面。\n3.数据类型:在C++中bool类可以与整型转换,但C#中bool类型和其他类型(特别是int)之间没有转换。long类型:在C#中,long9\n数据类型为64位,而在C++中为32位。\n4.struct类型:在C#中,类和结构在语义上不同。struct是值类型,而class是引用类型。\n5.switch语句:与C++中的switch语句不同,C#不支持从一个case标签贵穿到另一个case标签。\n6.delegate类型:委托与C++中的函数指针基本相似,但前者具有有类型安全,是安全的\n7.从派生类调用重写基类成员。base\n8.使用new修饰符显式隐藏继承成员。\n9.重写方法需要父类方法中用virtual声名,子类方法用override关键字。\n10.预处理器指令用于条件编译。C#中不使用头文件。C#预处理器指令\n11.异常处理:C#中引入了finally语句,这是C++没有的。\n12.C#运算符:C#支持其他运算符,如is和typeof。它还还引入了某些逻辑运算符的不同功能。\n13.static的使用,static方法只能由类名调用,改变static变量。\n14.在构造基类上替代C++初始化列表的方法。\n15.Main方法和C++及Java中的main函数的声明方式不同,Mair而不能用main\n16.方法参数:C#支持ref和out参数,这两个参数取代指看针通过引用传递参数。17.在C#中只能在unsafe不安全模式下才使用指针。\n18.在C#中以不同的方式执行重载运算符。\n19.字符串:C#字符串不同于C++字符串。\n20.foreach:C#從VB中引入了foreach关键字使得以循环访问数组目和集合。\n21.C#中没有全局方法和全局变量:方法和变量必须包含在类型型声明(如class或struct)中。\n22.C#中没有头文件和#include指令:using指令用于引用其他未完全限定类型名的命名空间中的类型。\n23.C#中的局部变量在初始化前不能使用。\n24.析构函数:在C#中,不能控制析构函数的调用时间,原因是析构函数由垃圾回收器自动调用。析构函数\n25.构造函数:与C++类似,如果在C#中没有提供类构造函数,则为您自动生成默认构造函数。该默认构造函数将所有字段初始化为\n它们的默认值。\n26.在C#中,方法参数不能有默认值。如果要获得同样的效果,需使用方法重载。"
  },
  {
    "id": 1769049168949,
    "question": "40.简述StringBuilder和String的区别?\n(字符串处理)",
    "answer": "String是字符串常量。StringBuffer是字符串变量,线程安全。StringBuider是字符串变量,线程不安\nString类型是个不可变的对象,当每次对String进行改变时都需要生成一个新的String对象,然后将指\n针指向一个新的对象,如果在一个循环里面,不断的改变一个对象,就要不断的生成新的对象,所以\n效率很低,建议在不断更改String对象的地方不要使用String类型2,\nStringBuilder对象在做字符串连接操作时是在原来的字符串上进行修改,改善了性能。这一点我们平\n时使用中也许都知道,连接操作频繁的时候,使用StringBuilder对象。"
  },
  {
    "id": 1769049475769,
    "question": "44. Mathf.Round和Mathf.Clamp和Mathf.Lerp含义?",
    "answer": "Mathf.Round:四舍五入\nMathf.Clamp:左右限值\nMathf.Lerp:插值"
  },
  {
    "id": 1769049772886,
    "question": "50.C#中四种访问修饰符是哪些?各有什么区别?",
    "answer": "1.属性修饰符\n2.存取修饰符\n3.类修饰符\n4.成员修饰符\n属性修饰符:\nSerializable:按值将对象封送到远程服务器。\nSTATread:是单线程套间的意思,是一种线程模型区。\nMATAThread:是多线程套间的意思,也是一种线程模\n型。\n存取修饰符:\npublic:存取不受限制。\nprivate:只有包含该成员的类可以存取。\ninternal:只有当前工程可以存取。\nprotected:只有包含该成员的类以及派生类可以存\n取。\n类修饰符:\nabstract:抽象类。指示一个类只能作为其它类的基\n类。\nsealed:密封类。指示一个类不能被继承。理所当\n然,密封类不能同时又是抽象类,因为抽象总是希望\n被继承的。成员修饰符:\nabstract:指示该方法或属性没有实现。\nsealed:密封方法。可以防止在派生类中对该方法的\noverride(『载)。不是类的每个成员方法都可以作为\n密封方法密封方法,必须对基类的虚方法进行 载,\n提供具体的实现方法。所以,在方法的声明中,\nsealed修饰符总是和override修饰符同时使用。\ndelegate:委托。用来定义一个函数指针。C#中的事\n件驱动是基于delegate+event的。\nconst:指定该成员的值只读不允许修改。\nevent:声明一个事件。\nextern:指示方法在外部实现。\noverride: 写。对由基类继承成员的新实现。\nreadonly:指示一个域只能在声明时以及相同类的内\n部被赋值。\nstatic:指示一个成员属于类型本身,而不是属于特定\n的对象。即在定义后可不经实例化,就可使用。\nvirtual:指示一个方法或存取器的实现可以在继承类中\n被覆盖。\nnew:在派生类中隐藏指定的基类成员,从而实现\n写的功能。若要隐藏继承类的成员,请使用相同名称\n在派生类中声明该成员,并用new修饰符修饰它。"
  },
  {
    "id": 1769050039518,
    "question": "52.什么是装箱拆箱,怎样减少操作",
    "answer": "C#装箱是将值类型转换为引用类型;\n拆箱是将引用类型转换为值类型。\n牵扯到装箱和拆箱操作比较多的就是在集合中,例如:ArrayList或者HashTable之类。"
  },
  {
    "id": 1769130452793,
    "question": "2.Unity3D中的碰撞器和触发器的区别?",
    "answer": "答:碰撞器是触发器的载体,而触发器只是碰撞器身上的一个属性。\n当lsTrigger=false时,碰撞器根据物理引擎引发碰撞,产生碰撞的交效果,可以调用OnCollisionEnter/Stay/Exit函数;\n当lsTrigger=true时,碰撞器被物理引擎所忽略,没有碰撞效果,可以调用OnTriggerEnter/Stay/Exit函数。\n如果既要检测到物体的接触又不想让碰撞检测影响物体移动或要检测一个物件是否经过空间中的某个区域这时就可以用到触发器。"
  },
  {
    "id": 1769131149345,
    "question": "5.如何安全的在不同工程间安全地迁移asset数据?三种方法",
    "answer": "1.将Assets和Library一起迁移\n2.导出包package\n3.用unity自带的assets Server功能"
  },
  {
    "id": 1769131269551,
    "question": "6.OnEnable,Awake,Start运行时的发生顺序?哪些可能在同一个对象周期中反复的发生?",
    "answer": "答:Awake->OnEnable->Start\nOnEnable在同一周期中可以反复地发生!"
  },
  {
    "id": 1769131413684,
    "question": "9.Unity提供了几种光源,分别是什么?",
    "answer": "平行光:Directional Light\n点光源:Point Light\n聚光灯:Spot Light\n区域光源:Area Light"
  },
  {
    "id": 1769131700755,
    "question": "16.如何优化内存?",
    "answer": "1.压缩自带类库;\n2.将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉;\n3.释放AssetBundle占用的资源;\n4.降低模型的片面数,降低模型的骨骼数量,降低贴图的大小;\n5.使用光照贴图,使用多层次细节(LOD),使用着色器(Shader)使用预设(Prefab)\n6.代码中少产生临时变量"
  },
  {
    "id": 1769131865162,
    "question": "18.动态加载资源的方式?",
    "answer": "instantiate:最简单的一种方式,以实例化的方式动态生成一个物体。\nAssetsbundle:即将资源打成asset bundle放在服务器或本地磁滋盘,然后使用WW模块get下来,然后从这个bundle中load某个\nobject,unity官方推荐也是绝大多数商业化项目使用的一种方式。\nResource.Load:可以直接load并返回某个类型的Object,前提是要把这个资源放在Resource命名的文件夹下,Unity不管有没有场景\n引用,都会将其全部打入到安装包中\n·AssetDatabase.loadasset:这种方式只在editor范围内有效,游戏运行时没有这个函数,它通常是在开发中调试用的。"
  },
  {
    "id": 1769132022597,
    "question": "19.使用Unity3d实现2d游戏,有几种方式?",
    "answer": "1.使用本身的GUI、UGUI\n2.把摄像机的Projection(投影)值调为Orthographic(正交投影),不下考虑z轴;\n3.使用2d插件,如:2DToolKit、NGUI"
  },
  {
    "id": 1769132470928,
    "question": "20.在物体发生碰撞的整个过程中,有几个阶段,分别列出对应的函数三个阶段",
    "answer": "OnCollisionEnter、OnCollisionStay、OnCollisionExit"
  },
  {
    "id": 1769389973211,
    "question": "1. Image和Rawlmage的区别",
    "answer": "·Imgae比Rawlmage更消耗性能\nImage只能使用Sprite属性的图片,但是Rawlmage什么样的都可以使用\nImage适合放一些有操作的图片,裁剪平铺旋转什么的,针又对Image Type属性\nRawlmage就放单独展示的图片就可以,性能会比lmage好很多"
  },
  {
    "id": 1769390347339,
    "question": "13.简述prefab的用处",
    "answer": "在游戏运行时实例化,prefab相当于一个模板,对你已经有的的素材、脚本、参数做一个默认的配置,以便于以后的修改,同事prefab打包\n的内容简化了导出的操作,便于团队的交流。"
  },
  {
    "id": 1769390606875,
    "question": "23.物体自身旋转使用的函数?",
    "answer": "Transform. Rotate()"
  },
  {
    "id": 1769390822707,
    "question": "25.Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期,请列出系统自带的几个重要的方法。",
    "answer": "答:Awake\n->Start->Update->FixedUpdate->LateUpdate >OnGU-->OnDisable-->OnDestroy\n主要执行顺序\n编辑器->初始化->物理系统->输入事件->游戏逻辑->场景渲染>GUI渲染->物体激活或禁用->销毁物体->应用结束\n主要函数介绍\nReset是在用户点击检视面板的Reset按钮或者首次添加该组件时被调周用。此函数只在编辑模式下被调用。Reset最常用于在检视面板中给一个\n最常用的默认值。\nAwake用于在游戏开始之前初始化变量或游戏状态。在脚本整个生命周期内它仅被调用一次.Awake在所有对象被初始比之后调用,所以你可以安\n全的与其他对象对话或用诸如GameObject.FindWithTag这样的函数搜索它们。每个游戏物体上的Awke以随机的顺序被调用。因此,你应该用\nAwake来设置脚本间的引用,并用Start来传递信息.Awake总是在Start之前被调用。它不能用来执行协同程序\nOnDisable不能用于协同程序。当对象变为不可用或非激活状态时此函数被调用。\nStart在behaviour的生命周期中只被调用一次。它和Awake的不同是Start只在脚本实例被启用时调用。你可以按需调整延迟初始化代码。Awake\n总是在Start之前执行。这允许你协调初始化顺序。\nFixedUpdate当MonoBehaviour启用时,其在每一帧被调用。处理Rigidbody时,需要用FixedUpdate代替Update。例如:给刚体加一个作用力时\n你必须应用作用力在FixedUpdate里的固定帧,而不是Update中的帧。(两者帧长不同)。\nOnTriggerEnter可以被用作协同程序,在函数中调用yield语句。当Collider(碰撞体)进入trigger(触发器)时调用OnTriggerEnter\nOnCollisionEnter相对于OnTriggerEnter,传递的是Collision类而不是Collider。Collision包含接触点,碰撞速度等细节。如果在函数中不使用碰\n撞信息,省略collisionlnfo参数以避免不必要的运算。注意如果碰撞体附加了一个非动力学刚体,只发送碰撞事件。可以被用作协同程序。\n当鼠标在GUIElement(GUI元素)或Collider(碰撞体)上点击时调用OnMouseDown\nUpdate是实现各种游戏行为最常用的函数。\nyield一个协同程序在执行过程中,可以在任意位置使用yield语句。yieId的返回值控制何时恢复协同程序向下执行。协同程序在对象自有帧行过\n程中堪称优秀。协同程序在性能上没有更多的开销。StartCoroutine函数是立刻返回的,但是yield可以延迟结果。直到协同程序执行完毕。\nLateUpdate是在所有Update函数调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时,跟随物体的相机可以在\nLateUpdate里实现。\n渲染和处理GUI事件时调用。这意味着你的OnGUI程序将会在每一帧被调用。要得到更多的GUI事件的信息查阅Event手册。如果Monobehaviour\n的enabled属性设为false,OnGUI()将不会被调用。\nOnApplicationQuit,当用户停止运行模式时在编辑器中调用。当web被关闭时在网络播放器中被调用。"
  },
  {
    "id": 1769390914443,
    "question": "26.物理更新一般放在哪个系统函数里?",
    "answer": "FixedUpdate,每固定帧绘制时执行一次,和Update不同的是FixedUpdate是渲染帧执行,如果你的渲染效率低下的时候FixedUpdate调\n用次数就会跟着下降。\nFixedUpdate比较适用于物理引擎的计算,因为是跟每帧渲染有关。Update就比较适合做控制。"
  },
  {
    "id": 1769390989603,
    "question": "28.如何销毁一个UnityEngine.Object及其子类?",
    "answer": "使用Destroy()方法;"
  },
  {
    "id": 1769391074051,
    "question": "30.请描述为什么Unity3d中会发生在组件上出现数据丢失的情况",
    "answer": "一般是组件上绑定的物体对象被删除了"
  },
  {
    "id": 1769391459467,
    "question": "35.MipMap是什么,作用?",
    "answer": "MipMapping:在三维计算机图形的贴图渲染中有常用的技术,为加快渲染进度和减少图像锯齿,贴图被处理成由一系列被预先计算和优\n化过的图片组成的文件,这样的贴图被称为MipMap。"
  },
  {
    "id": 1769391715875,
    "question": "36.请描述Interface与抽象类之间的不同",
    "answer": "语法不同处:\n1.抽象类中可以有字段,接口没有。\n2.抽象类中可以有实现成员,接口只能包含抽象成员。\n3.抽象类中所有成员修饰符都可以使用,接口中所有的成员都是对外的,所以不需要修饰符修饰。\n用法不同处:\n1.抽象类是概念的抽象,接口关注于行为。\n2.抽象类的子类与父类的关系是泛化关系,耦合度较高,而实现类和接口之间是实现的关系,耦合度比泛化低\n3.一个类只能继承一个类,但是可以实现多个接口。"
  },
  {
    "id": 1769391971467,
    "question": "40.如何让已经存在的GameObject在LoadLevel后不被卸载掉?",
    "answer": "DontDestroyOnLoad(transform.gameObject);"
  },
  {
    "id": 1769392102147,
    "question": "42.向量的点乘、叉乘以及归一化的意义?",
    "answer": "叉乘几何意义:得到一个与这两个向量都垂直的向量,这个向量的的模是以两个向量为边的平行四边形的面积\n点乘几何意义:可以用来表征或计算两个向量之间的夹角,以及在b向量在a向量方向上的投影\n1.点乘描述了两个向量的相似程度,结果越大两向量越相似,还可表示投影\n2.叉乘得到的向量垂直于原来的两个向量\n3.标准化向量:用在只关系方向,不关心大小的时候"
  },
  {
    "id": 1769392217491,
    "question": "44.当一个细小的高速物体撞向另一个较大的物体时,会出现什么情况?如何避免?",
    "answer": "穿透(碰撞检测失败)\n(例如CS射击游戏,可以使用开枪时发射射线,射线碰撞到则掉血击中)"
  },
  {
    "id": 1769392418268,
    "question": "48.什么叫动态合批?跟静态合批有什么区别?",
    "answer": "如果动态物体共用着相同的材质,那么Unity会自动对这些物体过进行批处理\n动态批处理操作是自动完成的,并不需要你进行额外的操作。\n区别:动态批处理一切都是自动的,不需要做任何操作,而且物体是可以移动的,但是限制很多。静态批处理:自由度很高,限制很少,\n缺点可能会占用更多的内存,而且经过静态批处理后的所有物体都不可以再移动了。"
  },
  {
    "id": 1769392643692,
    "question": "50.什么是LightMap?",
    "answer": "LightMap:就是指在三维软件里实现打好光,然后渲染把场景各表面的光照输出到贴图上,最后又通过引擎贴到场景上,这样就更物体有\n了光照的感觉。"
  },
  {
    "id": 1769476925884,
    "question": "57.如何在Unity3D中查看场景的面数,顶点数和DrawCall数?如何降低DrawCall数?",
    "answer": "在Game视图右上角点击Stats。降低Draw Call的技术是Draw CallBatching"
  },
  {
    "id": 1769477177027,
    "question": "60.四元数有什么作用?",
    "answer": "对旋转角度进行计算时用到四元数"
  },
  {
    "id": 1769477323667,
    "question": "64.有A和B两组物体,有什么办法能够保证A组物体永远比B组物体先渲染?",
    "answer": "把A组物体的渲染对列大于B物体的渲染队列"
  },
  {
    "id": 1769477419307,
    "question": "65.将图片的TextureType选项分别选为Texture和Sprite有什么区别",
    "answer": "Sprite作为Ul精灵使用,Texture作用模型贴图使用。"
  },
  {
    "id": 1769477525875,
    "question": "67.什么是DrawCall?DrawCall高了又什么影响?如何降低DrawCall?",
    "answer": "Unity中,每次引擎准备数据并通知GPU的过程称为一次Draw Call。DrawCall越高对显卡的消耗就越\n大。降低DrawCall的方法:\nDynamic Batching\nStatic Batching\n高级特性Shader降级为统一的低级特性的Shader。"
  },
  {
    "id": 1769478387411,
    "question": "72.层剔除",
    "answer": "用layermask,通过位运算的方式去设置\n在代码中使用时如何开启某个Layers?\nLayerMaskmask=1<<你需要开启的Layers层。\nLayerMaskmask=0<<你需要关闭的Layers层。\nLayerMask mask = 1 << 2; 表示开启Layer2。\n\nLayerMask mask = 0 << 5;表示关闭Layer5。\n\nLayerMask mask = 1<<2|1<<8;表示开启Layer2和Layer8。\n\nLayerMask mask = 0<<3|0<<7;表示关闭Layer3和Layer7。"
  },
  {
    "id": 1769478643242,
    "question": "74.画布的三种模式.缩放模式",
    "answer": "屏幕空间-覆盖模式(ScreenSpace-Overlay),Canvas创建出来后,默认就是该模式,该模式和\n摄像机无关,即使场景内没有摄像机,UI游戏物体照样渲染\n。屏幕空间:电脑或者手机显示屏的2D空间,只有x轴和y轴\n。覆盖模式:Ul元素永远在3D元素的前面\n屏幕空间-摄像机模式(ScreenSpace-Camera),设置成该模式后需要指定一个摄像机游戏物\n体,指定后UGUI就会自动出现在该摄像机的\"投射范围\"内,和NGUI的默认UIRoot效果一致,如\n果隐藏掉摄像机,UGUI当然就无法渲染\n世界空间模式(WorldSpace),设置成该模式后UGUI就相当于是场景内的一个普通的\"Cube游戏\n模型\",可以在场景内任意的移动UGUI元素的位置,通常用于怪物血条显示和VR开发\n缩放模式:\nProperty:\nFunction:\nCanvas中Ul元素的缩放模\nUI Scale Mode\n式\n使UI保持自己的尺寸,与\nConstant Pixel Size\n屏幕尺寸无关。\nScale With Screen Size\n屏幕尺寸越大,UI越大\n使UI元素保持相同的物理\n大小,与屏幕尺寸无关。\nConstant Physical Size\nConstant Pixel Size、Constant Physical Size实际上他们本质是一样的,只不过\nConstant Pixel Size通过逻辑像素大小调节来维持缩放,而Constant Physical Size\n通过物理大小调节来维持缩放。"
  },
  {
    "id": 1769479129602,
    "question": "75.FSM有限状态机",
    "answer": "FSM是一种数据结构,它由以下几个部分组成:\n1.内在的所有状态(必须是有限个)\n2.输入条件\n3.状态之间起到连接性作用的转换函数\n为什么要用FSM?\n因为它编程快速简单,易于调试,性能高,与人类思维相似从而便于梳理,灵活且容易修改\nFSM的描述性定义:\n一个有限状态机是一个设备,或是一个模型,具有有限数量的状态。它可以在任何给定时间根据输入\n进行操作,使得系统从一个状态转换到另一个状态,或者是使一个输出或者一种行为的发生,一个有\n限状态机在任何瞬间只能处于一种状态。\nState状态基类,定义了基本的Enter,Update,Exit三种状态行为,通常在这三种状态行为的方法里\n会写一些逻辑。每个State都会有StatelD(状态id,可以是枚举等),FSMControl(控制该状态的状\n态控制器的引用),Check方法(用来进行状态判断,并返回StatelD,通过FSMControl驱动)\nFSMControl,包含了一下FSMMachine,封装层。\nFSMMachine,驱动它的State列表,Update方法调用当前State的Chedk方法来获得StatelD,当\ncurrentState的Check方法返回的StatelD和当前StatelD不同,则切换状态。\n这是一个简单的FSM状态机系统,根据需要自己写个Control继承FSMCControl来驱动状态。因为\nCheck是State的职责,所以每一个不同对象的行为如Human的ledle和Dog的ldel区分肯定也不同。因此\n需要分别去写HumanldleState和DogldleState。如果还有Cat, PFish,可想而知代码量会有多么庞大。\n因此我将FSMControl抽象为一个公共基类,把State的Check具本实现作为FSMControl的Virtual方\n法。这样在ldleState里的Check方法就不用写具体的状态切换判断逻辑,而是调用它FSMControl子类\n(自己写的继承自FSMControl的Control类)的重写方法\n这样每次添加的新对象只要有ldle这个状态,就可以用一个公用的Stateldle,状态切换的逻辑差异放\n在Control层"
  },
  {
    "id": 1769563013931,
    "question": "76.使用过哪些Unity插件",
    "answer": "因人而异,可以去简单了解一下要说的插件,没用过也可以,至少你知道这个插件了!\n插件名\n作用\nshader graph\n制作shader光影效果\ncinemachine+timeline+postprocessingstack\n制作过场动画\nnodecanvas\n制作怪物ai\neasytouch\n手游触摸控制\nDo Tween\n动画插件\nFungus\n对话插件\n3D WebView\n浏览器插件\nVectrosity\n划线插件\nAVPro Video\n视频播放插件"
  },
  {
    "id": 1769563523686,
    "question": "1.unity常用资源路径有哪些",
    "answer": "//获取的目录路径最后不包含  /\n//获得的文件路径开头包含 /\nApplication.dataPath; //Asset文件夹的绝对路径\n//只读\nApplication.streamingAssetsPath;  //StreamingAssets文件夹的绝对路径（要先判断是否存在这个文件夹路径）\nApplication.persistentData ; //可读写\n\n//资源数据库 (AssetDatabase) 是允许您访问工程中的资源的 API\nAssetDatabase.GetAllAssetPaths; //获取所有的资源文件（不包含meta文件）\nAssetDatabase.GetAssetPath(object) //获取object对象的相对路径\nAssetDatabase.Refresh(); //刷新\nAssetDatabase.GetDependencies(string); //获取依赖项文件\n\n\nDirectory.Delete(p, true); //删除P路径目录\nDirectory.Exists(p);  //是否存在P路径目录\nDirectory.CreateDirectory(p); //创建P路径目录\n\nAssetDatabase //类库，对Asset文件夹下的文件进行操作，获取相对路径，获取所有文件，获取相对依赖项\nDirectory //类库，相关文件夹路径目录进行操作，是否存在，创建目录，删除等操作"
  },
  {
    "id": 1769563692091,
    "question": "3.unity提供了一个用于保存读取数据的类,(playerPrefs),请列出保存读取整形数据的函数",
    "answer": "PlayerPrefs类是一个本地持久化保存与读取数据的类\nPlayerPrefs类支持3中数据类型的保存和读取,浮点型,整形,和字符串型。\n分别对应的函数为:\nSetlnt();保存整型数据;Getlnt();读取整形数据;\nSetFloat();保存浮点型数据;GetFlost();读取浮点型数据;\nSetString(),保存字符串型数据;GetString(),读取字符串型数据;"
  },
  {
    "id": 1769565536849,
    "question": "6.AssetBundle加载",
    "answer": "1. LoadFromMemory(LoadFromMemoryAsync)\n2. LoadFrom File (LoadFrom FileAsync)\n3. UnityWebRequest\n4. LoadAssetsByWWWW(LoadFromCacheOrDownload)"
  },
  {
    "id": 1769649328698,
    "question": "4.协同程序的执行代码是什么?有何用处,有何缺点?",
    "answer": "官方案例)\nfunction Start() {\n// - After 0 seconds, prints \"Starting 0.0\"\n// - After 0 seconds, prints \"Before WaitAndPrint\nFinishes 0.0\"\n// - After 2 seconds, prints \"WaitAndPrint 2.0\" // 先打印\"Starting 0.0\"和\"Before WaitAndPrint\nFinishes 0.0\"两句,2秒后打印\"WaitAndPrint 2.0\" print (\"Starting \" + Time.time );\n// Start function WaitAndPrint as a coroutine. And continue execution while it is running\n// this is the same as WaintAndPrint(2.0) as the compiler does it for you automatically\n// 协同程序WaitAndPrint在Start函数内执行,可以视 同于它与Start函数同步执行.\nStartCoroutine(WaitAndPrint(2.0));\nprint (\"Before WaitAndPrint Finishes \" + Time.time );\n}\nfunction WaitAndPrint (waitTime : float) {\n// suspend execution for waitTime seconds // 暂停执行waitTime秒\nyield WaitForSeconds (waitTime);\nprint (\"WaitAndPrint \"+ Time.time );\n}\n作用:一个协同程序在执行过程中,可以在任意位置使\n用yield语句。yield的返回值控制何时恢复协同程序向下执行。协同程序在对象自有帧执行过程中堪称\n优秀。协同程序在性能上没有更多的开销。缺点:协同程序并非真线程,可能会发生堵塞。"
  },
  {
    "id": 1769995115834,
    "question": "C#中的主要集合类型及其特点如下：",
    "answer": "数组（Array）：固定大小，连续内存存储，元素类型统一，通过索引可快速访问元素。\n动态数组（ArrayList）：动态大小，可存储任意类型对象，但存取可能涉及装箱拆箱，有性能损耗。\n列表（List）：动态大小，类型安全，避免了装箱拆箱，可通过索引快速访问元素。\n字典（Dictionary<TKey, TValue>）：以键值对形式存储，键唯一，可通过键快速查找值，元素无序。\n集合（HashSet）：元素唯一，查找、插入和删除操作快，元素无序。\n队列（Queue）：先进先出，按元素添加顺序依次处理。\n栈（Stack）：后进先出，适合实现回溯、撤销等功能。"
  },
  {
    "id": 1769996062043,
    "question": "在C#中，多态性可以通过重载（Overload）和重写（Override）来实现，但它们之间有着显著的不同：",
    "answer": "重载是指在同一个类中，允许多个方法具有相同的名称，但参数列表不同（可以是参数的类型、数量或者顺序）。\n重写是指在派生类中重新定义基类中的虚方法。通过虚拟方法（virtual）和重写（override）机制实现。"
  },
  {
    "id": 1769997654667,
    "question": "什么是强类型、弱类型语言?哪种更好?",
    "answer": "强类型语言\n强类型语言是一种强制类型定义的语言,即一旦某一个变量被定义类型,如果不经强制转换,那么它永远就是\n该数据类型。\n在强类型语言中,变量的数据类型是严格定义的,编译择器或解释器会强制确保变量只能存储与其数据类型相\n匹配的值。\n类型转换通常需要显式地进行,以确保数据的一致性和安全性E。\n强类型语言通常提供更多的类型安全性,因为编译器会捕获类类型不匹配的错误。\n代表语言:C#、Java、Python、Go等。\n弱类型语言\n弱类型语言是一种弱类型定义的语言,某一个变量被定义类型,该变量可以根据环境变化自动进行转换,不需\n要经过现行强制转换。\n·在弱类型语言中,变量的数据类型不是严格定义的,变量可以在不同的上下文中自动进行类型转换。\n·类型转换通常是隐式的,由编译器或解释器自动处理。这可能导致潜在的类型错误不容易被发现。\n·弱类型语言可能更灵活,但也更容易引入错误,因为不同数据类型之间的操作可能不受限制。\n代表语言:JavaScript、PHP、Perl、Visual Basic等。"
  },
  {
    "id": 1770082135364,
    "question": "访问关键字base,this",
    "answer": "base\nbase关键字用于从派生类中访问基类的成员。如果要执行以下不操作时使用它:\n?调用基类上已被其他方法重写的方法。\n·指定创建派生类实例时应调用的基类构造函数。\n仅允许基类访问在构造函数、实例方法和实例属性访问器中进行。\n在静态方法中使用base关键字将产生错误。\n所访问的基类是类声明中指定的基类。例如,如果指定class ClassB:ClassA,则从ClassB访问ClassA的\n成员,而不考虑ClassA的基类。\nthis\nthis关键字指代类的当前实例,还可用作扩展方法的第一个参数的修饰符。\n备注\n本文介绍this在类实例中的用法。若要深入了解它在扩展方法中的用法,请参阅扩展方法。\n以下是this的常见用法:\n·限定类似名称隐藏的成员,例如:C#复制"
  },
  {
    "id": 1770082433465,
    "question": "C#as和is运算符区别和用法",
    "answer": "is运算符\nis运算符用于检查对象是否是某个特定类型,或者是否可以转传换为该类型。它返回一个布尔值(true或\nfalse).\nC#7.0引入了模式匹配,允许在is表达式中进行类型检查和转换:\n从C#11开始,可以使用列表模式来匹配列表或数组的元素。以下代码检查数组中处于预期位置的整数\nas 运算符\nas运算符尝试将对象转换为特定类型,如果转换失败,则返回null而不是抛出异常。它通常用于在不需要\n显式检查对象是否为特定类型的情况下进行安全的类型转换。"
  },
  {
    "id": 1770083578807,
    "question": "const和readonly关键字区别",
    "answer": "基本介绍\nconst(常量):在C#中用于声明编译时常量,其值在编译时就必须确定,并且在程序生命周期内不\n可更改。\n·readonly(只读字段):在C#中用于声明运行时常量,其值可以从在声明时或构造函数中初始化,之\n后不可更改(可通过反射强制修改)。"
  },
  {
    "id": 1770083863744,
    "question": "静态类与非静态类的区别?",
    "answer": "1.静态类无法实例化(换句话说,无法使用new运算符创建类类型的变量。由于不存在任何实例变量,因此\n可以使用类名本身访问静态类的成员)。\n2.静态构造函数只调用一次,在程序所驻留的应用程序域的生存期内,静态类会保留在内存中(即使用Static修\n饰的类,应用一旦启用静态类就会保留在内存中)。\n3.静态类只包含静态成员\n4.不能包含实例构造函数。\n5.静态类会进行密封,因此不能继承。它们不能继承自任何类(除了Object)。静态类不能包含实例构造函\n数。但是,它们可以包含静态构造函数。"
  }
]